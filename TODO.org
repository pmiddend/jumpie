* Animationssystem
  - Atlasing, online oder offline
    - Offline: man tut mehrere Bilder mit PS in eins und schreibt eine
      JSON-Datei, wo welches Bild liegt
      - Inhalt der Datei: Paare von Bezeichner und Koordinaten und Groesse:
	#+BEGIN_SRC json
	{
	  "player_fly_l" : [[0,0],[40,40]],
	  "player_fly_r" : [[0,0],[40,40]]
	}
	#+END_SRC
      - Gespiegelte Bilder von Hand oder automatisch?
	#+BEGIN_SRC json
	{
	  "player_fly_l" : [[0,0],[40,40]],
	  "player_fly_r" : "mirror player_fly_l"
	}
	#+END_SRC
      - Animationen separat von Bildstrukturen, separates Element (pro png-Datei):
	#+BEGIN_SRC json
	{
	  "images" : {
	    "player_walk_0" : [[0,0],[40,40]]
	    "player_walk_1" : [[41,0],[40,40]]
          },
	  "animations" : {
	    "player_walk" : { "frame_duration_secs" : 0.1, "frames" : ["player_walk_0","player_walk_1"] }
	  }
	}
	#+END_SRC
      - Verarbeitung
	- Bilder werden wie gehabt in Form von Paaren zwischen Bild
          und Position/Groesse eingelesen (=SurfaceData=).
	- Separate Animationsstruktur wird aufgebaut mit Animation als Menge von Surface-IDs erstmal.
    - Online: man tut die Bilder in benannte Ordner und das Programm
      kompiliert das zu ein oder mehreren geatlasten Bildern
* Sonicphysik
** Gesetze

  - Koordinatensystem faengt oben links an, groessere Y-Werte sind
    weiter unten.
  - Die Spielerposition bezeichnet horizontal und vertikal den
    Mittelpunkt des Spielers.

** Sensor fuer Waende

  - Waende werden mit Hilfe zweier Linien detektiert. Sie beginnen bei
    y+4 (also 4 unterhalb des Spielerzentrums) und sind nach links
    bzw. nach rechts 10 Pixel weit.
  - Jeder Sensor prueft jedes Frame auf eine Kollision mit einem Tile.
  - Stellt der linke Sensor eine Kollision fest, wird die
    Geschwindigkeit des Spielers auf 0 gesetzt und der Spieler auf
    "rechte Kante des Kollisionstiles-1" gesetzt. Analog fuer rechts.

** Sensor fuer Boeden

  - Zwei weitere Sensorlinien (diesmal wirklich Linien, keine Rechtecke)
    - von Spielerposition aus horizontal x+9 und x-9
    - von Spielerposition aus vertikal von y+20 (Groundlevel) bis y+20+16
  - Wenn die Sensoren etwas detektieren, wird Sonic auf das
    kollidierende Tile - 20 gesetzt.
  - Wenn beide Sensoren nichts detektieren, fliegt Sonic (ist ein neuer State).

** Flugzustand

  - Andere Menge von Sensoren.
  - Sensorlinie fuer Waende, beginnend bei seiner y-Position (also in
    seinem Zentrum) und von seiner x-Position +10 und -10 weggehend.
    - Wenn eine Kollision mit der Sensorlinie festgestellt wird, wird
      er wieder neu positioniert (siehe die Ground-Sensorlinie) und
      seine x-Geschwindigkeit wird auf 0 gesetzt, wenn er sich in
      Richtung des Tiles bewegt. Sonst bleibt die Geschwindigkeit so.
  - Sensoren fuer Bodenkollision quasi genau wie im Bodenzustand,
    allerdings leicht abgeaendert: Wenn sie Bodensensoren ein Tile zum
    Kollidieren finden, wird Sonic nicht automatisch auf
    Bodenhoehe-20 gesetzt, sondern nur, wenn er mindestens so hoch
    ist wie das kollidierende Tile.
  - Die Bodensensoren sind deaktiviert, falls die y-Geschwindigkeit
    positiv ist (er nach oben fliegt, sozusagen).
  - Es gibt noch Sensoren oberhalb seines Kopfes, die genau wie die
    Bodensensoren funktionieren.

** Laufen

  - Wird rechts gedrueckt, erhoeht sich die Geschwindigkeit um
    acc=0.046875. Wird links gedrueckt, erhoeht sie sich um das
    Negative dessen.
  - Bewegt man sich in die /eine/ Richtung, drueckt aber die Taste in
    die /andere/ Richtung, wird nicht einfach der Beschleunigungswert
    auf die Geschwindigkeit addiert, sondern es wird 0.5 addiert.
  - Wird keine der Pfeiltasten gedrueckt, wird folgende Formel
    ausgewertet: vx=vx - min(abs(vx,frc),frc) * signum(vx), wobei frc
    dasselbe wie acc ist.
  - Maximalgeschwindigkeit ist 6px pro Step.

** Fliegen

  - air = 2*acc, grv = 0.21875
  - Wird rechts/links gedrueckt, wird air addiert (keine Unterscheidung wie oben)
  - Gleicher Topspeed in der Luft, 6.
  - grv wird jede Iteration auf vy addiert.
  - Air Drag wird erstmal ignoriert.
  - Wenn man auf dem Boden ist und Space drueckt, wird die y-Geschwindigkeit auf -6.5 (jmp) gesetzt.
  - When you release the jump button in the air after jumping, the
    computer checks to see if Sonic is moving upward (i.e. Y speed is
    negative). If he is, then it checks to see if Y speed is less than
    -4 (e.g. -5 is "less" than -4). If it is, then Y speed is set to
    -4.

** Code

  - Funktion =PlayerState -> Environment -> [InputActions] -> PlayerState=
  - =PlayerState= enthaelt
    - Position
    - Geschwindigkeit
    - Zustand (fliegend oder laufend)
  - =Environment= enthaelt
    - Liste von Rechtecken, den "solid tiles", mit denen auf Kollision
      geprueft wird.
  - Die Funktion teilt sich am Anfang nach dem Zustand. Im fliegenden
    Zustand muss etwas anderes gemacht werden als im Laufenden.
  - Genereller Ablauf
    - Kollision mit Wand testen, x-Position und x-Geschwindigkeit wird angepasst
    - Kollision mit Boden testen, y-Position und y-Geschwindigkeit
      wird angepasst, ggf. wird der Modus zu fliegend gewechselt.
    - Tasteneingabe pruefen, Geschwindigkeit in x und y wird
      angepasst, ggf. wird der Modus gewechselt.
    - Reibung anwenden, Geschwindigkeit in x und y wird angepasst.
  - Visualisierung komplett ohne Sprites, nur mit Linesegments
  - Code noch zu ergaenzen: Schnitt Rechteck mit Linesegment
    - Da muss noch "inside" abgeprueft werden, das muss allerdings in
      Intersection, nicht in LineSegment oder Rect.
