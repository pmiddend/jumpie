* Ansatz allgemeiner
  - Erstelle Funktion, die den Algorithmus fuer die Plattformen umsetzt
    - Input sei
      - eine ggf. unendlich lange Liste "[a]"
      - eine Bedingung "a -> a -> Bool"
    - Output sei
      - eine Liste [a]
    - Wenn Eingabeliste leer, dann Ausgabe leer
    - Sammle bisher aufgenommene Elemente "ns"
    - Waehle erstes Element aus dieser Liste (das erfuellt die
      Bedingung ja auf jeden Fall), packe in "ns"
    - Waehle im naechsten Schritt das naechste Element aus der Liste. Teste, ob Bedingung mit allen "ns" erfuellt ist. Falls ja, packe da rein.
* TODO
- [0/1] Animationssystem
  - [ ] Ggf. Animation abhaengig von Spielergeschwindigkeit machen
    (mit einem Koeffizienten neben der momentan berechneten
    Geschwindigkeit)
- [X] Bei Recordtypen auf get-Notation umsteigen
- [X] Alle Typen aus =Types= auslagern
- [X] Renderfunktionen in =Render=-Modul auslagern
- [ ] Terraingenerierung
  - Plattformen
    - Bestehen aus 3 Bildern (Anfang, Mitte, Ende), koennen
      unterschiedlich lang sein
    - Mehrere Typen moeglich mit unterschiedlicher Friction
    - Wo werden die Plattformen generiert?
    - Bildschirm in regulaeres Gitter einteilen, wenn man 800x600 als
      Aufloesung und 40x40 als Tilegroesse annimmt, kriegt man das
      sogar glatt hin.
    - Vertikale Plattformen (also Waende)
    - Was sind die Randbedingungen?
      - Plattformen sollten erreichbar sein
      - Gegeben zwei Plattformen A und B. Kann der Spieler von A nach B und zurueck?
      - Seien A und B auf derselben Hoehe, dann ist das moeglich, wenn
        es zwei Punkte a und b auf den Plattformen gibt, die weniger
        als "r" voneinander entfernt sind, wobei "r" die Distanz ist,
        die der Spieler innerhalb der Flugzeit beim Springen
        zuruecklegen kann.
      - Sie die Hoehendifferenz zwischen den Plattformen "h".
      - Die Flugbahn des Spielers beim Springen ist eine Parabel. Man
        kann die zwei Plattformen fuers erste als Linien betrachten.
      - Sei h0 die Hoehe (der y-Wert) der unteren Plattform der
        beiden. Zeichne die (!) Parabelkurve ausgehend von dem
        Endpunkt der Linie, der am naechsten zu einem Endpunkt der
        anderen Linie entfernt ist. Berechne den Schnittpunkt der
        Parabel mit der Linie. Wenn es keinen gibt, kann man die
        Plattform nicht erreichen.
	- Wie bekommt man die Parabelgleichung fuer das Spiel?
	  - p(t) = x0 + v_x_max * t,grv/2*t*t-v_y_max*t+y0)
	- Wie lautet die Schnittpunktgleichung Liniensegment mit Parabel?
	  - Siehe proto.hs
	- Wie wendet man das _konstruktiv_ an?
	  - Man generiert auf dem Spielfeld eine Plattform mit
            zufaelliger Position und Laenge und testet dann, ob sie "passt".
	    - Fuer den Test, ob sie passt, muesste es ausreichen zu
              testen, ob sie von einer bisher generierten Plattform erreichbar ist.
	    - Induktion der Aussage: Der eben beschriebene Algorithmus
              erzeugt im n'ten Schritt eine Menge von 'n' Plattformen,
              wobei jede von jeder anderen aus erreichbar ist. Induktion ueber 'n'
	      - Induktionsanfang: eine einzige Plattform ist von jeder anderen aus erreichbar.
	      - Induktionsschritt: Sein {P_1,...P_{n-1}} eine Menge
                von n-1 Plattformen. Der Algorithmus hat eine neue
                Plattform P_n generiert, die von P_i aus erreichbar
                ist (wobei 1<=i<=n-1). Sei P_j eine beliebige andere
                Plattform aus {P_1,...,P_{n-1}. Dann kommt man von P_n
                auf P_i und laut Induktionsannahme von P_i zu jeder
                anderen Plattform.
	- Algorithmus zum Generieren der Plattform-Menge in Haskell:
	  - Arbeitet auf regulaerem Gitter, spuckt Menge von (p0,p1)
            aus, wobei p0 und p1 die Gitterpunkte des Anfangs und des
            Endes sind.
	  - Generiert unendlich lange Liste zufaelliger Plattformen
	    - Dazu wird zuerst ein (x,y)-Paar gewuerfelt und dann eine
              Plattformlaenge.
	      - Wie verhindert man, dass zwei Plattformen ueberlappen?
	      - Man filtert die Liste spaeter ja eh, da kann man die
                ungueltigen gut rausfiltern.
	    - Algorithmus weiter prinzipiell: Gegeben bisher
              ausgewaehlte Plattformliste, waehle neue
              Plattform. Teste ob Plattform sich mit bisherigen
              ueberschneidet. Falls nein, teste ob Plattform von einer
              der bisherigen Plattformen erreichbar ist. Falls ja,
              nehme Plattform in Menge auf.
	    - Auf die resultierende Menge wird noch ein take 20
              gemacht oder so.
	    - Algorithmus bekommt Tilegrenzen gesteckt.
- [ ] Sounds
- [ ] Fonts
- [ ] Einheitensystem, um die haessliche Konvertierung von =GameTicks= z.B. zu vermeiden
- [ ] Geschosse, Gegner
- [ ] Punkte
